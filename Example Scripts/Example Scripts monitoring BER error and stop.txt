# 本示例展示了获取主窗口中的内容，搜索指定字符串，获取该字符串同一行后方的数字，判断该数字是否不为0，如果不为0则弹出窗口提示并结束脚本运行，如果为0则继续后续的执行。
# LANEDATA: lane:4, errorStatus: 0, laneErrors: 0, errorCount:0
# 上面一行是需要搜寻的行，最后一个数字是被监控的数字

# 发送读取BER的命令，此处xxxx为示例，替换为实际的命令
send xxxx

# 等待#符号，确保命令响应已出现在窗口中
wait for # for 3

# 获取文本区域当前结束位置
end_index = gui.text_area.index("end-1c")
 
# 往回取 n 行（n需要替换为实际需要搜寻的行数）
start_index = gui.text_area.index(f"{end_index} - {n} lines")
 
# 获取这段文本内容
text_to_search = gui.text_area.get(start_index, end_index)
 
# 匹配 LANEDATA 行，提取 errorCount
match_pattern = r'LANEDATA:\s*lane:\d+,\s*errorStatus:\s*\d+,\s*laneErrors:\s*\d+,\s*errorCount:(\d+)'
matche_result = re.finditer(match_pattern, text_to_search)
 
# 检查是否有 errorCount > 0 的情况
for match in matche_result:
    error_count = int(match.group(1))
    if error_count != 0:
        messagebox.showinfo("提示", f"检测到 errorCount > 0（值为 {error_count}），已中止脚本。")
        raise StopLoopException("stop")

# 脚本需要遵守python的缩进规则，python通过缩进来识别哪些属于一个大括号（if/for/while等）中的内容。
# 缩进建议全部使用4n个空格或者全部使用tab。



